from datetime import datetime, timedelta, timezone
from typing import Union, Annotated

from contextlib import asynccontextmanager

import jwt
from jwt.exceptions import InvalidTokenError
from fastapi import Depends, FastAPI, HTTPException, status, Query
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware

from pwdlib import PasswordHash

from pydantic_settings import BaseSettings, SettingsConfigDict

import os
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi

from pydantic import BaseModel

SECRET_KEY = "02b68540063b967e41f15dced7b908d3a4e69fc6a7ac8ff658b4f73e1d55582a"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30



db_uri = os.environ.get("MONGODB_URI")

client = MongoClient(db_uri, server_api=ServerApi('1'))

db_success = ""

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

from sqlmodel import Field, Session, SQLModel, create_engine, select

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str

class HeroPublic(HeroBase): # what is returned to the client
    id: int

# validates data from clients, also how I would handle passwords?
class HeroCreate(HeroBase): # what is to be inserted into the db (it adds a secret name)
    secret_name: str

# because types change, we need to re-declare all the fields
class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None


class User(SQLModel):
    username: str = Field(primary_key=True, index=True)
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = False

class UserInDB(User, table=True):
    hashed_password: str


class UserCreate(User):
    plain_password: str


POSTGRESQL_URL = "postgresql://jonathan@localhost:5432/mydb"
engine = create_engine(POSTGRESQL_URL)

def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

def get_session():
    with Session(engine) as session:
        yield session

SessionDep = Annotated[Session, Depends(get_session)]

@asynccontextmanager
async def lifespan(app: FastAPI):
    create_db_and_tables()
    yield

app = FastAPI(lifespan=lifespan)

# validated hero now also has an id generated by the database
# the actual return type is Hero but response model is HeroPublic so fastapi validates, serielizes data
@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return hero

    # TODO: add duplicate check
    user = User.model_validate(user) # not sure if this is necassary here

@app.post("/users", response_model=User)
def create_user(user: UserCreate, session: SessionDep):
    db_user = UserInDB(
        **user.model_dump(),
        hashed_password=get_password_hash(user.plain_password)
    )
    potentially_existing_db_user = session.get(UserInDB, user.username)
    if potentially_existing_db_user:
        raise HTTPException(status_code=409, detail="Username already taken")
    session.add(db_user)
    session.commit()
    session.refresh(db_user)
    return user

def get_user(username: str, session: SessionDep):
    user_db = session.get(UserInDB, username)
    if not user_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    user = user_db.model_dump(exclude={"hashed_password"})
    return user

# here again we use HeroPublic so data then is validated and serialized
@app.get("/heroes", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes

@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep) -> Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero

@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_id:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True) # exclude_unset => remove default values
    hero_db.sqlmodel_update(hero_data) # update hero_db with data from hero_data
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db

@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    }
}



password_hash = PasswordHash.recommended()

def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)

def get_password_hash(password):
    return password_hash.hash(password)


    
def authenticate_user(username: str, password: str, session: SessionDep):
    user_in_db = session.get(UserInDB, username)
    if not user_in_db:
        return False
    if not verify_password(password, user_in_db.hashed_password):
        return False
    return user_in_db

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

OAuth2SchemeDI = Annotated[str, Depends(oauth2_scheme)]

async def get_current_user(token: OAuth2SchemeDI, session: SessionDep):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username == None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(username=token_data.username, session=session)
    if user is None:
        raise credentials_exception
    return user

GetCurrentUserDI = Annotated[User, Depends(get_current_user)]

async def get_current_active_user(current_user: GetCurrentUserDI):
    current_user = User.model_validate(current_user)
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

try:
    client.admin.command('ping')
    db_success = "Pinged your deployment. You successfully connected to MongoDB!"
except Exception as e:
    db_success = e

origins = [
    "https://swipeback.pages.dev",
]

GetCurrentActiverUserDI = Annotated[User, Depends(get_current_active_user)]

OAuth2PasswordRequestFormDI = Annotated[OAuth2PasswordRequestForm, Depends()]

@app.post("/token")
async def login_for_access_token(form_data: OAuth2PasswordRequestFormDI, session: SessionDep):
    user = authenticate_user(form_data.username, form_data.password, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer",}
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return Token(access_token=access_token, token_type="bearer")

@app.get("/users/me/", response_model=User)
async def read_users_me(current_user: GetCurrentActiverUserDI):
    return current_user
@app.get("/user/me/items")
async def read_own_items(
    current_user: GetCurrentActiverUserDI
):
    return [{"item_id": "Foo", "owner": current_user.username}]


app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def read_root():
    return {"Hello": "World", "db_success": db_success}



@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}

@app.get("/items")
async def read_items(token: OAuth2SchemeDI):
    return {"token": token}
